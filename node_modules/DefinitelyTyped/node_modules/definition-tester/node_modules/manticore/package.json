{
  "name": "manticore",
  "version": "0.2.4",
  "description": "Mythical multi-process worker pool",
  "keywords": [
    "multiprocess",
    "worker",
    "job",
    "pool"
  ],
  "homepage": "https://github.com/Bartvds/manticore",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Bartvds/manticore.git"
  },
  "author": {
    "name": "Bart van der Schoor",
    "url": "https://github.com/Bartvds"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://raw.github.com/Bartvds/manticore/master/LICENSE-MIT"
    }
  ],
  "bugs": {
    "url": "https://github.com/Bartvds/manticore/issues"
  },
  "engines": {
    "node": ">= 0.10.0"
  },
  "scripts": {
    "prepublish": "grunt prepublish",
    "build": "grunt build",
    "test": "grunt test"
  },
  "main": "./dist/index.js",
  "typescript": {
    "definition": "./dist/manticore.d.ts"
  },
  "dependencies": {
    "JSONStream": "^0.8.4",
    "bluebird": "^1.2.4",
    "through2": "^0.5.1",
    "type-detect": "^0.1.2"
  },
  "devDependencies": {
    "chai": "^1.9.1",
    "grunt": "~0.4.2",
    "grunt-contrib-clean": "~0.5.0",
    "grunt-contrib-copy": "^0.5.0",
    "grunt-contrib-jshint": "^0.10.0",
    "grunt-dts-bundle": "^0.2.0",
    "grunt-mocha-test": "^0.11.0",
    "grunt-shell": "^0.7.0",
    "grunt-ts": "^1.10.0",
    "grunt-ts-clean": "^0.2.0",
    "grunt-tslint": "~0.4.1",
    "jshint-path-reporter": "^0.1.3",
    "mocha-unfunk-reporter": "^0.4.0",
    "source-map-support": "~0.2.5",
    "tslint-path-formatter": "~0.1.0",
    "typescript": "^1.0.1"
  },
  "readme": "# manticore\r\n\r\n<img src=\"https://i.imgur.com/HFN1Nyi.jpg\" title=\"μαρτιχώρα, martichora\" />\r\n\r\n[![Build Status](https://secure.travis-ci.org/Bartvds/manticore.svg?branch=master)](http://travis-ci.org/Bartvds/manticore) [![NPM version](https://badge.fury.io/js/manticore.svg)](http://badge.fury.io/js/manticore) [![Dependency Status](https://david-dm.org/Bartvds/manticore.svg)](https://david-dm.org/Bartvds/manticore) [![devDependency Status](https://david-dm.org/Bartvds/manticore/dev-status.svg)](https://david-dm.org/Bartvds/manticore#info=devDependencies)\r\n\r\n> Mythical multi-process worker pool\r\n\r\nFork node.js multi-core workers and crunch legendary workloads.\r\n\r\nThe core concept is you got some code in a function that does some heavy work and you want to run it many times with maximum benefit of your multi-core CPU, and without the overhead of re-spawning piles single-use sub-processes.\r\n\r\n:warning: Early release :sunglasses:\r\n\r\n\r\n## Why yet another worker module?\r\n\r\nThe worker modules I found on npm all have their problems: they either lack functionality, use external dependencies or make all kinds of weird assumptions that get in the way.\r\n\r\nInstead of trying to wrangle my app to fit those unsatisfactory modules I build Manticore to be simple and effective with the features you need to get big things done at hyperspeed without jumping through crazy hoops.\r\n\r\n\r\n## How to use?\r\n\r\nYou put your code in a function that accepts a single parameter, then add a bunch of them in a worker module. In this module you register the functions to expose them as tasks.\r\n\r\nIn your main app you setup the pool for that module and execute the methods via the pool with your data parameter and Manticore will spawn (and despawn) workers as needed and distribute the work and return the result as a Promise.\r\n\r\nYou can use a function that returns a value synchronously, or go asynchronous and either use the node.js-style callback or return a Promise. \r\n\r\nBy default each worker works on only one job at a time, but there is an option to allow workers to process multiple jobs simultaneously that allows a extra boost for IO-bound tasks (of course assuming you use async IO).\r\n\r\n\r\n## Return value\r\n\r\nThe return value of the pool is always a ES6-style Promise so you easily use fancy logic like Promise.all() or Promise.race().\r\n\r\nFor some next level setups you can leverage Promise-glue helpers from modules like Q, Bluebird etc. To get creative and pass the Promises into more exotic modules like React, Baconjs, Lazy.js, Highland and all the other cool utility modules with Promise support.\r\n\r\nKeep in mind the parameter object and return value are serialised so you cannot pass functions or prototype based objects, only simple JSON-like data.\r\n\r\n\r\n## Notes\r\n\r\n- Returns a ES6 Promise.\r\n- Transfers data between threads using pipes (eg: non-blocking).\r\n- Data gets serialised so only primitive JSON-like data can be transferred.\r\n- Makes sure you configure concurrent/paralel to suit your app for best performance\r\n\r\n## Todo\r\n\r\n- Swap JSON serialisation for something that supports Buffers.\r\n- Separate settings per function.\r\n\r\n## Usage\r\n\r\n### Setup worker\r\n\r\nPut the worker methods in their own module where they are registered to Manticore:\r\n\r\n````js\r\nvar mc = require('manticore');\r\n\r\n// directly add named function\r\nfunction myFunc1(params) {\r\n\treturn heavyStuff(params);\r\n}\r\nmc.registerTask(myFunc1);\r\n\r\n// add anonymous function\r\nmc.registerTask('myFunc2', function(params) {\r\n\treturn heavyStuff(params);\r\n});\r\n````\r\n\r\nThere are different ways to return values:\r\n\r\n````js\r\n// does it run syncronous?\r\nfunction myFunc1(params) {\r\n    return heavyStuff(params);\r\n}\r\n\r\n// maybe use the node-style callback?\r\nfunction myFunc2(params, callback) {\r\n    heavyStuff(params, function(err, result) {\r\n        callback(err, result);\r\n    });\r\n}\r\n\r\n// or return a Promise?\r\nfunction myFunc3(params) {\r\n    return heavyStuff(params).then(function(res) {\r\n        return someMoreWork(res)\r\n    };\r\n}\r\n````\r\n\r\nRegister in bulk:\r\n````js\r\n// add named functions as array\r\nmc.registerTasks([\r\n    myFunc1,\r\n    myFunc2,\r\n    myFunc3\r\n]);\r\n\r\n// register the methods as an object to redefine the name\r\n// - protip: use the module.exports object\r\nmc.registerTasks({\r\n    myFuncA: myFunc1\r\n    myFuncB: myFunc2\r\n    myFuncC: myFunc3\r\n});\r\n````\r\n\r\n## Use the pool\r\n\r\nCreate a pool in the main app:\r\n\r\n````js\r\nvar mc = require('manticore');\r\n\r\nvar pool = mc.createPool({\r\n\tmodulePath: require.resolve('./worker'),\r\n\tconcurrent: 4\r\n});\r\n````\r\n\r\n\r\nThen run the methods by name, pass a parameter value and get a Promise:\r\n\r\n````js\r\npool.run('myFunc1', myParams).then(function(res) {\r\n    // got results\r\n}, function(err) {\r\n    // oops\r\n});\r\n````\r\n\r\nFor convenience get a curried function:\r\n\r\n````js\r\nvar func1 = pool.curried('myFunc1');\r\n\r\nfunc1(params).then(function(res) {\r\n    // got results\r\n});\r\n````\r\n\r\nPro-tip: for serious bulk processing use `Promise.all()` (in Bluebird this is fun with `Promise.map()` etc).\r\n\r\n````js\r\nPromise.all(myArray.map(pool.curried('myFunc1'))).then(function(results) {\r\n    // got all the results\r\n});\r\n````\r\n\r\nThat's it! :+1:\r\n\r\n\r\n### Pool options\r\n\r\n````ts\r\nvar pool = mc.createPool({\r\n\t// path to the worker module. pro-tip: use require.resolve()\r\n\tworker: string;\r\n\t\r\n\t// maximum amount of worker processes\r\n\t// - defaults: require('os').cpus().length\r\n\t// tip: when running on many cores leave 1 core free for main process: require('os').cpus().length -1\r\n\tconcurrent?: number;\r\n\t// maximum amount of jobs to pass to each worker\r\n\t// set this to a higher value if your jobs are async and IO-bound\r\n\t// - default: 1\r\n\tparalel?: number;\r\n\t// maximum retries if a worker fails\r\n\tattempts?: number;\r\n\r\n\t// worker idle timeout in miliseconds, shuts down workers that are idling\r\n\tidleTimeout?: number;\r\n\t\r\n\t// emit 'status' events, handy for debugging\r\n\temit?: boolean;\r\n\t// console.log status events for debugging\r\n\tlog?: boolean;\r\n});\r\n````\r\n\r\n\r\n## Development\r\n\r\nManticore is written in TypeScript and compiled with Grunt. \r\n\r\nFor TypeScript user there is a `.d.ts` file both in the repo and bundled in the npm package (also exported in package.json).\r\n\r\n\r\n## Build\r\n\r\nInstall development dependencies in your git checkout:\r\n\r\n````bash\r\n$ npm install\r\n````\r\n\r\nBuild and run tests using [grunt](http://gruntjs.com):\r\n\r\n````bash\r\n$ grunt test\r\n````\r\n\r\nSee the `Gruntfile.js` for additional commands.\r\n\r\n\r\n## Contributions\r\n\r\nThey are welcome but please discuss in [the issues](https://github.com/Bartvds/manticore/issues) before you commit to large changes. If you send a PR make sure you code is idiomatic and linted.\r\n\r\n\r\n## History\r\n\r\n- 0.2.0 - Transfer data over non-blocking pipes, renamed `modulePath` option to `worker`.\r\n- 0.1.0 - First release.\r\n\r\n\r\n## License\r\n\r\nCopyright (c) 2014 Bart van der Schoor @ [Bartvds](https://github.com/Bartvds)\r\n\r\nLicensed under the MIT license.\r\n",
  "readmeFilename": "README.md",
  "_id": "manticore@0.2.4",
  "_shasum": "3321a3f615dd9026f053400d498b823ca4d2bab5",
  "_resolved": "https://registry.npmjs.org/manticore/-/manticore-0.2.4.tgz",
  "_from": "https://registry.npmjs.org/manticore/-/manticore-0.2.4.tgz"
}
