var Promise = require('bluebird');
var TestRunItem = (function () {
    function TestRunItem(test) {
        this.attempts = 0;
        this.test = test;
        this.defer = Promise.defer();
    }
    return TestRunItem;
})();
/////////////////////////////////
// Parallel execute Tests
/////////////////////////////////
var TestQueue = (function () {
    function TestQueue(concurrent) {
        this.retries = [];
        this.queue = [];
        this.active = [];
        this.maxRetry = 3;
        this.maxConcurrent = Math.max(1, concurrent);
        this.concurrent = this.maxConcurrent;
    }
    // add to queue and return a promise
    TestQueue.prototype.run = function (test) {
        var item = new TestRunItem(test);
        this.queue.push(item);
        this.check();
        return item.defer.promise;
    };
    TestQueue.prototype.check = function () {
        while (this.queue.length > 0 && this.active.length < this.concurrent) {
            this.step();
        }
        // when done go for retries
        if (this.queue.length === 0 && this.active.length === 0 && this.retries.length > 0) {
            this.queue = this.retries;
            this.retries = [];
            // lower the concurrency (fight out-of-memory errors)
            this.concurrent = Math.max(1, this.concurrent / 2);
            // check again
            this.check();
        }
    };
    TestQueue.prototype.step = function () {
        var _this = this;
        var item = this.queue.pop();
        item.attempts++;
        item.test.run().then(function (res) {
            // see if we can retry
            if (!res.success && item.attempts < _this.maxRetry) {
                if (res.stderr && /^Killed/.test(res.stderr)) {
                    _this.retries.push(item);
                    return;
                }
            }
            res.attempts = item.attempts;
            item.defer.resolve(res);
        }).catch(function (err) {
            item.defer.reject(err);
        }).finally(function () {
            var i = _this.active.indexOf(item);
            if (i > -1) {
                _this.active.splice(i, 1);
            }
            process.nextTick(function () {
                _this.check();
            });
        });
        this.active.push(item);
    };
    return TestQueue;
})();
module.exports = TestQueue;
